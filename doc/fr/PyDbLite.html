<p><h2>Moteur pur Python</h2>

<ul>
<li>importer la classe <CODE>Base</CODE> du module PyDbLite : <span class="python">from PyDbLite import Base</span>
</ul>

<h3>Créer ou ouvrir une base de données</h3>

<ul>
<li>créer une instance de base de données,en passant un nom de fichier : <span class="python">db = Base('test.pdl')</span>

<li>pour une nouvelle base, définissez les noms des champs : <span class="python">db.create('nom','age','taille')</span>

<br>Vous n'avez pas à définir le type des champs. PyDbLite accepte toute valeur qui peut être sérialisée par le module <CODE>cPickle</CODE> : des chaînes de caractères, des chaînes Unicode, des entiers, réels, dates et dates-heures (instances des classes <CODE>date</CODE> et <CODE>datetime</CODE> dans le module <CODE>datetime</CODE>), des instances de classes définies par l'utilisateur, etc

<li>si la base existe déjà, pour l'ouvrir : <span class="python">db.open()</span>

<li>on peut passer un paramètre "mode" à la méthode <CODE>create()</CODE>, pour indiquer ce qu'il faut faire si la base existe déjà sur le disque
<ul>
<li>mode = "open" : <span class="python">db.create('nom','age','taille',mode="open")</span>

ouvre la base en ignorant la définition des champs

<li> mode = "override" : <span class="python">db.create('nom','age','taille',mode="override")</span>

efface la base existante et en crée une nouvelle avec les définitions de champs
<li>si le mode n'est pas précisé et que la base existe déjà, une exception <CODE>IOError</CODE> est déclenchée</ul>
</ul>
</ul>

<h3>Insertion, mise à jour, suppression d'enregistrements</h3>

<ul>
<li>insertion d'un nouvel enregistrement
<ul>
<li>par mots-clés : <span class="python">db.insert(nom='homer',age=23,taille=1.84)</span>

<br>Si certains champs manquent, ils sont initialisés à la valeur <CODE>None</CODE>

<li>par arguments positionnels : <span class="python">db.insert('homer',23,1.84)</span>

<br>Les arguments doivent être fournis dans le même ordre que dans la méthode <CODE>create()</CODE>
</ul>

<li>pour sauvegarder les changements sur le disque : <span class="python">db.commit()</span>
<br>Si vous ne confirmez pas les changements, les opérations d'insertion, de suppression et de mise à jour ne seront pas sauvegardés sur le disque

<li>En plus des champs passés à la méthode <CODE>create()</CODE>, un champ interne appelé <CODE>__id__</CODE> est ajouté. C'est un entier, unique et inchangé pour chaque enregistrement, il peut donc être utilisé comme identifiant pour l'enregistrement

<li> un autre champ interne appelé <CODE>__version__</CODE> est également géré par le moteur de base de données. Il s'agit d'un entier qui est initialisé à 0 quand l'enregistrement est créé, et incrémenté de 1 à chaque fois que l'enregistrement est mis à jour. Ceci sert pour la détection des accès concurrents, par exemple dans une application web dans laquelle deux utilisateurs veulent mettre à jour le même enregistrement en même temps

<li>pour mettre à jour un enregistrement : <span class="python">db.update(record,age=24)</span>

<li>pour supprimer un enregistrement : <span class="python">db.delete(record)</span> ou, si vous connaissez l'identifiant : <span class="python">del db[rec_id]</span>

<li>pour supprimer une liste d'enregistrements : <span class="python">db.delete(liste_d_enregistrements)</span>

<br><CODE>liste_d_enregistrements</CODE> peut être n'importe quel itérable (liste, tuple, set, etc) qui produit des enregistrements

</ul>

<h3>Sélection</h3>

<ul><h5>Accès direct</h5>

<li>on peut accéder directement à un enregistrement par son identifiant : <span class="python">record = db[rec_id]</span>

retourne l'enregistrement tel que record['__id__'] == rec_id

<li>pour les sélections simples :
<span class="python">db(cle1=val1,cle2=val2)</span> renvoie la liste des enregistrements dont les clés prennent les valeurs données

<li><span class="python">db(cle1) >= val1</span> retourne un itérateur sur tous les enregistrements pour lesquels la valeur du champ cle1 est supérieur ou égal à val1. Exemple :
<blockquote><span class="python">for rec in (db("age")>30):<br>
&nbsp;&nbsp;&nbsp;&nbsp;	print rec["nom"]	</span></blockquote>
<li>ces "comparaisons riches" peuvent être combinées avec des & (et) et des | (ou) :<br>
<blockquote><span class="python">for rec in (db("age")>30) & (db("pays") == "France"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;print rec["nom"]</span></blockquote>
</ul>

<ul><h5>Listes en intension</h5>

<li>L'instance de Base est un itérateur sur les enregistrements. Pour itérer sur tous les enregistrements :
<br><span class="python">for r in db:<br>
&nbsp;&nbsp;&nbsp;&nbsp;fais_qqch_avec(r)</span>
<li>la sélection d'enregistrements peut utiliser la syntaxe des listes en intension ("list comprehensions") de Python :
<br><span class="python">recs = [ r for r in db if 30 > r['age'] >= 18 and r['taille'] < 2 ]</span>

<br>retourne les enregistrements de la base pour lesquels l'âge est compris entre 18 et 30 ans, et la taille est inférieure à 2 mètres. L'enregistrement est un dictionnaire, où la clé est le nom de champ et la valeur est la valeur de ce champ

<li>la syntaxe des générateurs d'expression Python peut aussi être utilisée :
<br><span class="python">for r in (r for r in db if r['nom'] in ('homer','marge') ):<br>
&nbsp;&nbsp;&nbsp;&nbsp;faire_qqch_avec(r)</span>

<br>itère sur les enregistrements dont le nom est 'homer' ou 'marge'
</ul>

<ul><h5>Index</h5>
<li>pour accélérer les sélections, un index peut être créé sur un champ : <span class="python">db.create_index('age')</span>

<br>Quand un index est créé, l'instance de la base de données a un attribut (ici <CODE>_age</CODE> : noter le signe de soulignement initial, pour éviter les conflits de noms avec des noms internes). Cet attribut est un objet de type dictionnaire, où les clés sont les valeurs prises par le champ, et les valeurs sont les enregistrements dont le champ a la même valeur que la clé :
<br><span class="python">records = db._age[23]</span> retourne la liste des enregistrements avec age == 23

<br>Si aucun enregistrement n'a cette valeur, la recherche par cette valeur retourne une liste vide

<br>L'index supporte l'itération sur les valeurs du champ, et la méthode <CODE>keys()</CODE> retourne toutes les valeurs existantes pour le champ

</ul>

<h3>Autres fonctions</h3>
<ul>
<li>nombre d'enregistrements dans la base : <span class="python">len(db)</span>

<li>pour ajouter un nouveau champ à une base existante et spécifier une valeur par défaut : <span class="python">db.add_field('nouveau_champ'[,default=v])</span>. Si le défaut n'est pas fourni, la valeur du champ est <CODE>None</CODE>

<li>pour supprimer un champ existant : <span class="python">db.drop_field('nom')</span>

<li>pour connaître la liste des champs : <span class="python">db.fields</span>

