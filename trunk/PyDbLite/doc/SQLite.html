<html>

<head>
<title>PyDbLite</title>
<link rel="stylesheet" href="pydblite.css">
</head>

<body>

<table width="100%" cellspacing="0" cellpadding="10">

<tr>
<td class="lnk" ><a href="licence.html">Licence</a>
</td>

<td class="navigation" align="center">PyDbLite</td>
<td class="lnk" align="right"><a href="index_fr.html">Français</a></td>

</tr>
</table>

<a name="sqlite"><p><h2>SQLite adapter</h2>
<p>The main difference with the pure-Python module is the syntax to identify a database and a table, and the need to specify field types on base creation
<p>For compliance with SQLite vocabulary, the module defines two classes, <code>Database</code> and <code>Table</code>
<p>The <code>Database</code> instances are built with the database path as argument :
<br><span class="python">db = Database('test.sqlite')</span>
<p>Instances of <code>Database</code> support a method <code>tables()</code>, returning the list of instances of <code>Table</code> for all the tables in the database
<p>Manipulating a table uses the same syntax as in PyDbLite :
<ul>
<li>import the class <code>Table</code> :
<span class="python">from PyDbLite.SQLite import Table</span>
<li>to create a <code>Table</code> instance (a table in the SQLite database) you pass 2 arguments : the table name, and the path to the database in the file system : <br><span class="python">db = Base('dummy','test')</span>
<li>to create the table you must specify an SQLite field type : <code>NULL, INTEGER, REAL, TEXT</code>
or <code>BLOB</code> :<br>
<span class="python">db.create(('name','TEXT'),('age','INTEGER'),('size','REAL'))</span>
</ul>
<p>For record insertion and update, the syntax is the same as above. The module only tries a few conversions between Python types and SQLite field types :
<p>
<table border="1">
<tr><th>SQLite type</th><th>Python type</th><th>Conversion</th></tr>
<tr><td>TEXT</td><td>str</td><td>none</td></tr>
<tr><td>TEXT</td><td>unicode</td><td>encode in utf-8</td></tr>
<tr><td>BLOB</td><td>str</td><td>none</td></tr>
<tr><td>BLOB</td><td>datetime.date</td><td>format date : YYYY-MM-DD</td></tr>
<tr><td>BLOB</td><td>datetime.datetime</td><td>format datetime : YYYY-MM-DD HH:MM:SS</td></tr>
<tr><td>INTEGER</td><td>int</td><td>none</td></tr>
<tr><td>REAL</td><td>float</td><td>none</td></tr>
</table>

<p>
For selection and deletion, the syntax is also the same as for the pure-Python <code>PyDbLite</code>. The SQLite primary key <code>rowid</code> is used like the key <code>__id__</code> to identify records

<p>Selection methods return dictionaries, with SQLite types converted to Python types like this :
<p>
<table border="1">
<tr><th>SQLite type</th><th>Python type</th></tr>
<tr><td>TEXT</td><td>unicode</td></tr>
<tr><td>BLOB</td><td>str</td></tr>
<tr><td>INTEGER</td><td>int</td></tr>
<tr><td>REAL</td><td>float</td></tr>
</table>
<p>Note that you can't use the <code>drop_field()</code> method, since dropping fields is not supported by SQLite
<p>The <code>Table</code> instance has an attribute <code>cursor</code>, so you can also execute
SQL expressions by <span class="python">db.cursor.execute(some_sql)</span> and get the result
by <br><span class="python">results = db.cursor.fetchall()</span>

</body>
</html>
