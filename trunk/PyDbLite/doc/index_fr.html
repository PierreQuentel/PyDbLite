<html>

<head>
<title>PyDbLite</title>
</head>

<body>

<style type="text/css">
body, td {
	color: #000000;
	background-color: #ffffff;
	font-family: sans-serif;
	font-size: 13;
	}

pre {
	font-family: arial }

li { padding-bottom:10;
	}

.python {
	color:330099;
	font-family: "Courier New";
	}

td.navigation
{ background-color: #99ccff;
  font-weight: bold;
  font-family: avantgarde, sans-serif;
  font-size: 110%;
  width: 90%}

td.lnk { background-color: #99ccff;
  font-size: 70%;
    }

td.tablename { vertical-align: top;
	text-align: center;
    font-weight: bold;
    }

ol { margin-left : 20px;
	}

</style>

<table width="100%" cellspacing="0"><tr><td class="navigation" align="center">PyDbLite</td>
<td class="lnk" align="right"><a href="index.html">English</a></td>
</tr></table>
<p>PyDbLite est un moteur de base de données en mémoire, en pur Python, qui utilise les "list comprehensions" de Python comme langage de requêtes au lieu de SQL

<p>Il consiste en un seul petit module, PyDbLite.py. Pour l'installer, il suffit de le <a href="http://sourceforge.net/project/platformdownload.php?group_id=210258">télécharger</a> et de le mettre dans le répertoire <code>Lib/site-packages</code> de votre distribution Python

<p>Utilisation :

<ul>
<li>importer la classe <CODE>Base</CODE> du module PyDbLite : <span class="python">from PyDbLite import Base</span>

<li>créer une instance de base de données,en passant un nom de fichier : <span class="python">db = Base('test')</span>

<li>pour une nouvelle base, définissez les noms des champs : <span class="python">db.create('nom','age','taille')</span>

<br>Vous n'avez pas à définir le type des champs. PyDbLite accepte toute valeur qui peut être sérialisée par le module <CODE>cPickle</CODE> : des chaînes de caractères, des chaînes Unicode, des entiers, réels, dates et dates-heures (instances des classes <CODE>date</CODE> et <CODE>datetime</CODE> dans le module <CODE>datetime</CODE>), des instances de classes définies par l'utilisateur, etc

<li>si la base existe déjà, pour l'ouvrir : <span class="python">db.open()</span>

<li>on peut passer un paramètre "mode" à la méthode <CODE>create()</CODE>, pour indiquer ce qu'il faut faire si la base existe déjà sur le disque
<ul>
<li>mode = "open" : <span class="python">db.create('nom','age','taille',mode="open")</span>

ouvre la base en ignorant la définition des champs

<li> mode = "override" : <span class="python">db.create('nom','age','taille',mode="override")</span>

efface la base existante et en crée une nouvelle avec les définitions de champs
<li>si le mode n'est pas précisé et que la base existe déjà, une exception <CODE>IOError</CODE> est déclenchée</ul>

<li>insertion d'un nouvel enregistrement
<ul>
<li>par mots-clés : <span class="python">db.insert(nom='homer',age=23,taille=1.84)</span>

<br>Si certains champs manquent, ils sont initialisés à la valeur <CODE>None</CODE>

<li>par arguments positionnels : <span class="python">db.insert('homer',23,1.84)</span>

<br>Les arguments doivent être fournis dans le même ordre que dans la méthode <CODE>create()</CODE>
</ul>

<li>pour sauvegarder les changements sur le disque : <span class="python">db.commit()</span>
<br>Si vous ne confirmez pas les changements, les opérations d'insertion, de suppression et de mise à jour ne seront pas sauvegardés sur le disque

<li>En plus des champs passés à la méthode <CODE>create()</CODE>, un champ interne appelé <CODE>__id__</CODE> est ajouté. C'est un entier, unique et inchangé pour chaque enregistrement, il peut donc être utilisé comme identifiant pour l'enregistrement

<li> un autre champ interne appelé <CODE>__version__</CODE> est également géré par le moteur de base de données. Il s'agit d'un entier qui est initialisé à 0 quand l'enregistrement est créé, et incrémenté de 1 à chaque fois que l'enregistrement est mis à jour. Ceci sert pour la détection des accès concurrents, par exemple dans une application web dans laquelle deux utilisateurs veulent mettre à jour le même enregistrement en même temps

<li>la sélection d'enregistrements utilise la syntaxe des "list comprehensions" de Python :
<br><span class="python">recs = [ r for r in db if 30 > r['age'] >= 18 and r['taille'] < 2 ]</span>

<br>retourne les enregistrements de la base pour lesquels l'âge est compris entre 18 et 30 ans, et la taille est inférieure à 2 mètres. L'enregistrement est un dictionnaire, où la clé est le nom de champ et la valeur est la valeur de ce champ

<li>la syntaxe des générateurs d'expression Python peut aussi être utilisée :
<br><span class="python">for r in (r for r in db if r['nom'] in ('homer','marge') ):<br>
&nbsp;&nbsp;&nbsp;&nbsp;faire_qqch_avec(r)</span>

<br>itère sur les enregistrements dont le nom est 'homer' ou 'marge'

<li>pour itérer sur tous les enregistrements :
<br><span class="python">for r in db:<br>
&nbsp;&nbsp;&nbsp;&nbsp;fais_qqch_avec(r)</span>

<li>on peut accéder directement à un enregistrement par son identifiant : <span class="python">record = db[rec_id]</span>

retourne l'enregistrement tel que record['__id__'] == rec_id

<li> finalement, un raccourci peut être utilisé pour les sélections simples :
<span class="python">db(cle1=val1,cle2=val2)</span> renvoie la liste des enregistrements dont les clés prennent les valeurs données. C'est équivalent à <span class="python">[ r for r in db if r["cle1"]==val1 and r["cle2"]==val2]</span>, mais en beaucoup plus concis

<li>pour accélérer les sélections, un index peut être créé sur un champ : <span class="python">db.create_index('age')</span>

<br>Quand un index est créé, l'instance de la base de données a un attribut (ici <CODE>_age</CODE> : noter le signe de soulignement initial, pour éviter les conflits de noms avec des noms internes). Cet attribut est un objet de type dictionnaire, où les clés sont les valeurs prises par le champ, et les valeurs sont les enregistrements dont le champ a la même valeur que la clé :
<br><span class="python">records = db._age[23]</span> retourne la liste des enregistrements avec age == 23

<br>Si aucun enregistrement n'a cette valeur, la recherche par cette valeur retourne une liste vide

<br>L'index supporte l'itération sur les valeurs du champ, et la méthode <CODE>keys()</CODE> retourne toutes les valeurs existantes pour le champ

<li>nombre d'enregistrements dans la base : <span class="python">len(db)</span>

<li>pour supprimer un enregistrement : <span class="python">db.delete(record)</span> ou, si vous connaissez l'identifiant : <span class="python">del db[rec_id]</span>

<li>pour supprimer une liste d'enregistrements : <span class="python">db.delete(liste_d_enregistrements)</span>

<br><CODE>liste_d_enregistrements</CODE> peut être n'importe quel itérable (liste, tuple, set, etc) qui produit des enregistrements

<li>pour mettre à jour un enregistrement : <span class="python">db.update(record,age=24)</span>

<li>pour ajouter un nouveau champ à une base existante et spécifier une valeur par défaut : <span class="python">db.add_field('nouveau_champ'[,default=v])</span>. Si le défaut n'est pas fourni, la valeur du champ est <CODE>None</CODE>

<li>pour supprimer un champ existant : <span class="python">db.drop_field('nom')</span>

<li>pour connaître la liste des champs : <span class="python">db.fields</span>

</ul>

</body>
</html>