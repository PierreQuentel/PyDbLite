<html>

<head>
<title>PyDbLite</title>
</head>

<body>

<style type="text/css">
body, td {
	color: #000000;
	background-color: #ffffff;
	font-family: sans-serif;
	font-size: 13;
	}

pre {
	font-family: arial }

li { padding-bottom:10;
	}

.python {
	color:330099;
	font-family: "Courier New";
	}

td.navigation
{ background-color: #99ccff;
  font-weight: bold;
  font-family: avantgarde, sans-serif;
  font-size: 150%;
  width: 90%}

td.lnk { background-color: #99ccff;
  font-size: 100%;
    }

td.tablename { vertical-align: top;
	text-align: center;
    font-weight: bold;
    }

ol { margin-left : 20px;
	}

</style>

<table width="100%" cellspacing="0" cellpadding="10">

<tr>
<td class="lnk" ><a href="licence_fr.html">Licence</a>
</td>

<td class="navigation" align="center">PyDbLite</td>
<td class="lnk" align="right"><a href="index.html">English</a></td>

</tr>
</table>
<p>PyDbLite est un moteur de base de données en mémoire, en pur Python, qui utilise les "list comprehensions" de Python comme langage de requêtes au lieu de SQL. Il consiste en un petit module, <code>PyDbLite.py</code>

<p>Le paquetage fournit également deux modules<code>SQLite.py</code> et <code>MySQL.py</code>. Ils permettent de manipuler des bases de données SQLite et MySQL avec la même syntaxe pythonique que le moteur PyDbLite en pur Python

<p>Pour l'installer, il suffit de le <a href="http://sourceforge.net/project/platformdownload.php?group_id=210258">télécharger</a> et de le mettre dans le répertoire <code>Lib/site-packages</code> de votre distribution Python

<p><h2>Moteur pur Python</h2>

<ul>
<li>importer la classe <CODE>Base</CODE> du module PyDbLite : <span class="python">from PyDbLite import Base</span>
</ul>

<h3>Créer ou ouvrir une base de données</h3>

<ul>
<li>créer une instance de base de données,en passant un nom de fichier : <span class="python">db = Base('test.pdl')</span>

<li>pour une nouvelle base, définissez les noms des champs : <span class="python">db.create('nom','age','taille')</span>

<br>Vous n'avez pas à définir le type des champs. PyDbLite accepte toute valeur qui peut être sérialisée par le module <CODE>cPickle</CODE> : des chaînes de caractères, des chaînes Unicode, des entiers, réels, dates et dates-heures (instances des classes <CODE>date</CODE> et <CODE>datetime</CODE> dans le module <CODE>datetime</CODE>), des instances de classes définies par l'utilisateur, etc

<li>si la base existe déjà, pour l'ouvrir : <span class="python">db.open()</span>

<li>on peut passer un paramètre "mode" à la méthode <CODE>create()</CODE>, pour indiquer ce qu'il faut faire si la base existe déjà sur le disque
<ul>
<li>mode = "open" : <span class="python">db.create('nom','age','taille',mode="open")</span>

ouvre la base en ignorant la définition des champs

<li> mode = "override" : <span class="python">db.create('nom','age','taille',mode="override")</span>

efface la base existante et en crée une nouvelle avec les définitions de champs
<li>si le mode n'est pas précisé et que la base existe déjà, une exception <CODE>IOError</CODE> est déclenchée</ul>
</ul>
</ul>

<h3>Insertion, mise à jour, suppression d'enregistrements</h3>

<ul>
<li>insertion d'un nouvel enregistrement
<ul>
<li>par mots-clés : <span class="python">db.insert(nom='homer',age=23,taille=1.84)</span>

<br>Si certains champs manquent, ils sont initialisés à la valeur <CODE>None</CODE>

<li>par arguments positionnels : <span class="python">db.insert('homer',23,1.84)</span>

<br>Les arguments doivent être fournis dans le même ordre que dans la méthode <CODE>create()</CODE>
</ul>

<li>pour sauvegarder les changements sur le disque : <span class="python">db.commit()</span>
<br>Si vous ne confirmez pas les changements, les opérations d'insertion, de suppression et de mise à jour ne seront pas sauvegardés sur le disque

<li>En plus des champs passés à la méthode <CODE>create()</CODE>, un champ interne appelé <CODE>__id__</CODE> est ajouté. C'est un entier, unique et inchangé pour chaque enregistrement, il peut donc être utilisé comme identifiant pour l'enregistrement

<li> un autre champ interne appelé <CODE>__version__</CODE> est également géré par le moteur de base de données. Il s'agit d'un entier qui est initialisé à 0 quand l'enregistrement est créé, et incrémenté de 1 à chaque fois que l'enregistrement est mis à jour. Ceci sert pour la détection des accès concurrents, par exemple dans une application web dans laquelle deux utilisateurs veulent mettre à jour le même enregistrement en même temps

<li>pour mettre à jour un enregistrement : <span class="python">db.update(record,age=24)</span>

<li>pour supprimer un enregistrement : <span class="python">db.delete(record)</span> ou, si vous connaissez l'identifiant : <span class="python">del db[rec_id]</span>

<li>pour supprimer une liste d'enregistrements : <span class="python">db.delete(liste_d_enregistrements)</span>

<br><CODE>liste_d_enregistrements</CODE> peut être n'importe quel itérable (liste, tuple, set, etc) qui produit des enregistrements

</ul>

<h3>Sélection</h3>

<ul><h5>Accès direct</h5>

<li>on peut accéder directement à un enregistrement par son identifiant : <span class="python">record = db[rec_id]</span>

retourne l'enregistrement tel que record['__id__'] == rec_id

<li>pour les sélections simples :
<span class="python">db(cle1=val1,cle2=val2)</span> renvoie la liste des enregistrements dont les clés prennent les valeurs données

<li><span class="python">db(cle1) >= val1</span> retourne un itérateur sur tous les enregistrements pour lesquels la valeur du champ cle1 est supérieur ou égal à val1. Exemple :
<blockquote><span class="python">for rec in (db("age")>30):<br>
&nbsp;&nbsp;&nbsp;&nbsp;	print rec["nom"]	</span></blockquote>
<li>ces "comparaisons riches" peuvent être combinées avec des & (et) et des | (ou) :<br>
<blockquote><span class="python">for rec in (db("age")>30) & (db("pays") == "France"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;print rec["nom"]</span></blockquote>
</ul>

<ul><h5>Listes en intension</h5>

<li>L'instance de Base est un itérateur sur les enregistrements. Pour itérer sur tous les enregistrements :
<br><span class="python">for r in db:<br>
&nbsp;&nbsp;&nbsp;&nbsp;fais_qqch_avec(r)</span>
<li>la sélection d'enregistrements peut utiliser la syntaxe des listes en intension ("list comprehensions") de Python :
<br><span class="python">recs = [ r for r in db if 30 > r['age'] >= 18 and r['taille'] < 2 ]</span>

<br>retourne les enregistrements de la base pour lesquels l'âge est compris entre 18 et 30 ans, et la taille est inférieure à 2 mètres. L'enregistrement est un dictionnaire, où la clé est le nom de champ et la valeur est la valeur de ce champ

<li>la syntaxe des générateurs d'expression Python peut aussi être utilisée :
<br><span class="python">for r in (r for r in db if r['nom'] in ('homer','marge') ):<br>
&nbsp;&nbsp;&nbsp;&nbsp;faire_qqch_avec(r)</span>

<br>itère sur les enregistrements dont le nom est 'homer' ou 'marge'
</ul>

<ul><h5>Index</h5>
<li>pour accélérer les sélections, un index peut être créé sur un champ : <span class="python">db.create_index('age')</span>

<br>Quand un index est créé, l'instance de la base de données a un attribut (ici <CODE>_age</CODE> : noter le signe de soulignement initial, pour éviter les conflits de noms avec des noms internes). Cet attribut est un objet de type dictionnaire, où les clés sont les valeurs prises par le champ, et les valeurs sont les enregistrements dont le champ a la même valeur que la clé :
<br><span class="python">records = db._age[23]</span> retourne la liste des enregistrements avec age == 23

<br>Si aucun enregistrement n'a cette valeur, la recherche par cette valeur retourne une liste vide

<br>L'index supporte l'itération sur les valeurs du champ, et la méthode <CODE>keys()</CODE> retourne toutes les valeurs existantes pour le champ

</ul>

<h3>Autres fonctions</h3>
<ul>
<li>nombre d'enregistrements dans la base : <span class="python">len(db)</span>

<li>pour ajouter un nouveau champ à une base existante et spécifier une valeur par défaut : <span class="python">db.add_field('nouveau_champ'[,default=v])</span>. Si le défaut n'est pas fourni, la valeur du champ est <CODE>None</CODE>

<li>pour supprimer un champ existant : <span class="python">db.drop_field('nom')</span>

<li>pour connaître la liste des champs : <span class="python">db.fields</span>

</ul>

<a name="sqlite"><p><h2>Adaptateur SQLite</h2>
<p>La seule différence avec le module en pur Python est la syntaxe pour identifier une table et la nécessité de spécifier le type des champs quand on crée une base
<p>Pour rester cohérent avec le vocabulaire de SQLite, on utilise plutôt le nom <code>Table</code> que <code>Base</code>
<ul>
<li>importer la classe <code>Table</code> :
<span class="python">from PyDbLite.SQLite import Table</span>
<li>pour créer une instance de <code>Base</code> (une table dans la base de données SQLite) il faut passer 2 argument : le nom de la table, et le chemin de la base dans le système de fichiers : <span class="python">db = Base('machpro','test')</span>
<li>pour créer une table il faut spécifier un type de champ SQLite : NULL, INTEGER, REAL, TEXT
ou BLOB : <span class="python">db.create(('nom','TEXT'),('age','INTEGER'),('taille','REAL'))</span>
<p>Pour simplifier, vous pouvez aussi utiliser les types DATE et DATETIME (ou TIMESTAMP), le programme fera lui-même les conversions entre les instances de <code>datetime.date</code> et
<code>datetime.datetime</code> et le type TEXT
</ul>
<p>Pour l'insertion, la sélection, la mise à jour et la suppression, la syntaxe est la même que ci-dessus. La seule différence est qu'on ne peut pas utiliser la méthode <code>drop_field()</code>, parce que la suppression de champs n'est pas supportée par SQLite
<p>L'instance de <code>Table</code> a un attribut <code>cursor</code>, ce qui permet d'exécuter des commandes SQL par <span class="python">db.cursor.execute(expression_sql)</span> et récupérer le résultat par <span class="python">results = db.cursor.fetchall()</span>

<p><a name="mysql"><h2>Adaptateur MySQL</h2>
<p>La seule différence avec le module en pur Python est la syntaxe pour identifier une <code>Base</code> et la nécessité de spécifier le type des champs quand on crée une base
<ul>
<li>importer la classe <code>Base</code> :
<span class="python">from PyDbLite.MySQL import Base</span>
<li>se connecter à la base de données MySQL :
<p><span class="python">import MySQLdb<br>
 connection = MySQLdb.connect("localhost","root","admin")<br>
 connection.cursor().execute("USE test")
 </span>

<li>passer la connection en argument de la création de Base : <span class="python">db = Base('machpro',connection)</span>
<li>pour créer une nouvelle base (une table dans la base MySQL), il faut spécifier des types de champs MySQL :
<span class="python">db.create(('nom','INTEGER'),('age','INTEGER'),('taille','REAL'))</span>
</ul>

<p>Pour l'insertion, la sélection, la mise à jour et la suppression, la syntaxe est la même que ci-dessus

<p>L'instance de <code>Base</code> a un attribute <code>cursor</code>, ce qui permet d'exécuter des commandes SQL par <span class="python">db.cursor.execute(expression_sql)</span> et récupérer le résultat par <span class="python">results = db.cursor.fetchall()</span>

</body>
</html>