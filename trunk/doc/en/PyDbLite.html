<html>

<head>
<title>PyDbLite</title>
<link rel="stylesheet" href="pydblite.css">
</head>

<body>

<table width="100%" cellspacing="0" cellpadding="10">

<tr>
<td class="lnk" >&nbsp;</td>
<td class="navigation" align="center">PyDbLite</td>
<td class="lnk" align="right"><a href="../fr/PyDbLite.html">Français</a></td>
</tr>

</table>
<table width="100%" cellspacing="0" cellpadding="10">

<tr>
<td class="menu">
<b>Documentation</b>
<a href="index.html">Home</a>
<br><a href="PyDbLite.html">Pure-Python engine</a>
<br><a href="SQLite.html">SQLite adapter</a>
<br><a href="MySQL.html">MySQL adapter</a>
<br><a href="conversions.html">Conversions</a>
<hr>
<b>Contacts</b>
<br><a href="http://groups.google.com/group/pydblite">Community</a>
<br><a href="contact.html">Contact</a>
<hr>
<b>Code</b>
<br><a href="http://sourceforge.net/project/platformdownload.php?group_id=210258">Download</a>
<br><a href="http://pydblite.svn.sourceforge.net/viewvc/pydblite">Browse SVN</a>
<hr>
<a href="bench.html">Benchmarks</a>
<hr>
<a href="licence.html">Licence</a>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
</td>
<td class="content">
<p><h2>Pure-Python engine</h2>

The pure-Python engine consists of one small module, <code>PyDbLite.py</code>
<p>
<ul>
<li> import class <CODE>Base</CODE> from module <CODE>PyDbLite</CODE> :
<span class="python">from PyDbLite import Base</span>
</ul>

<h3>Create or open a database</h3>
<ul>
<li> create a database instance, passing it a path in the file system : <span class="python">db = Base('dummy.pdl')</span>

<li>for a new database, define the field names : <span class="python">db.create('name','age','size')</span>

<br>You don't have to define the field types. PyDbLite will accept any value that
can be serialized by the <CODE>cPickle</CODE> module : strings, Unicode strings, integers,
floats, dates and datetimes (instances of the <CODE>date</CODE> and <CODE>datetime</CODE> classes in the <CODE>datetime</CODE> module), user-defined classes, etc

<li> if the base exists, open it : <span class="python">db.open()</span>

<li> you can pass a parameter "mode" to the <CODE>create()</CODE> method, to specify what
you want to do if the base already exists in the file system
<ul>
<li>mode = "open" : <span class="python">db.create('name','age','size',mode="open")</span>

    opens the database and ignores the field definition

<li> mode = "override" : <span class="python">db.create('name','age','size',mode="override")</span>

    erases the existing base and creates a new one with the field definition

<li> if mode is not specified and the base already exists, an <CODE>IOError</CODE> is raised
</ul>

</ul>

<h3>Insert, update, delete a record</h3>
<ul>
<li> insert a new record
<ul>
<li> by keywords : <span class="python">db.insert(name='homer',age=23,size=1.84)</span>

<br>If some fields are missing, they are initialized with the value <CODE>None</CODE>

<li> by positional arguments : <span class="python">db.insert('homer',23,1.84)</span>

<br>The arguments must be provided in the same order as in the <CODE>create()</CODE> method
</ul>

<li>save the changes on disk : <span class="python">db.commit()</span>
<br>If you don't commit the changes, the insertion, deletion and update operations
will not be saved on disk. To return to the previous version, just <span class="python">
open()</span> it again (this is equivalent to rollback in transactional
databases)

<li> besides the fields passed to the <CODE>create()</CODE> method, an internal field called <CODE>__id__</CODE> is added. It is a integer which is guaranteed to be unique and unchanged for each record in the base, so that it can be used as the record identifier

<li> another internal field called <CODE>__version__</CODE> is also managed by the database engine. It is a integer which is set to 0 when the record is created, then incremented by 1 each time the record is updated. This is used to detect concurrency control, for instance in a web application where 2 users select the same record and want to update it at the same time

<li>to delete a record : <span class="python">db.delete(record)</span> or, if you know the record identifier : <span class="python">del db[rec_id]</span>

<li>to delete a list of records : <span class="python">db.delete(list_of_records)</span>

<br><CODE>list_of_records</CODE> can be any iterable (list, tuple, set, etc) yielding records

<li>to update a record : <span class="python">db.update(record,age=24)</span>

</ul>

<h3>Selection</h3>

<ul><h5>Direct access</h5>
<li> a record can be accessed by its identifier : <span class="python">record = db[rec_id]</span>

returns the record such that record['__id__'] == rec_id

<li>for simple selections :
<span class="python">db(key1=val1,key2=val2)</span> returns the list of records where the keys take the given values

<li><span class="python">db(key1) >= val1</span> returns an iterator on all records where the value of the field key1 is greater or equal to val1. Example :
<blockquote><span class="python">for rec in (db("age")>30):<br>
&nbsp;&nbsp;&nbsp;&nbsp;    print rec["name"]   </span></blockquote>
<li>such "rich comparison" operations can be combined with & (and) and | (or) :<br>
<blockquote><span class="python">for rec in (db("age")>30) & (db("country") == "France"):<br>
&nbsp;&nbsp;&nbsp;&nbsp;print rec["name"]</span></blockquote>
</ul>

<ul><h5>List comprehension</h5>
<li>The instance of Base is a Python iterator ; to iterate on all the records :
<br><span class="python">for r in db:<br>
&nbsp;&nbsp;&nbsp;&nbsp;do_something_with(r)</span>
<li>the selection of records can use Python list comprehension syntax :
<br><span class="python">recs = [ r for r in db if 30 > r['age'] >= 18 and r['size'] < 2 ]</span>

<br>returns the records in the base where the age is between 18 and 30, and size is below 2 meters. The record is a dictionary, where the key is the field name and value is the field value

<li> Python generator expression syntax can also be used :
<br><span class="python">for r in (r for r in db if r['name'] in ('homer','marge') ):<br>
&nbsp;&nbsp;&nbsp;&nbsp;do_something_with(r)</span>

<br>iterates on the records where the name is one of 'homer' or 'marge'

</ul>

<ul><h5>Index</h5>
    <li>to speed up selections, an index can be created on a field : <span class="python">db.create_index('age')</span>

    <br>When an index is created, the database instance has an attribute (here <CODE>_age</CODE> : note the heading underscore, to avoid name conflicts with internal names). This attribute is a dictionary-like object, where keys are the values taken by the field, and values are the records whose field values are egal to the key :
    <br><span class="python">records = db._age[23]</span> returns the list of records with age == 23

    <br>If no record has this value, lookup by this value returns an empty list

    <br>The index supports iteration on the field values, and the <CODE>keys()</CODE> method
    returns all existing values for the field
</ul>

<h3>Other functions</h3>

<li>number of records in the base : <span class="python">len(db)</span>

<li>to add a new field to an existing base and specify a default value : <span class="python">db.add_field('new_field'[,default=v])</span>. If no default is provided, the field value is <CODE>None</CODE>

<li>to drop an existing field : <span class="python">db.drop_field('name')</span>

<li>to get the list of fields : <span class="python">db.fields</span>

</ul>


</td>
</tr>
</table>

</body>
</html>